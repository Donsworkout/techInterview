[목록으로](https://github.com/Donsworkout/techInterview/blob/master/README.md)

## 1. Thread / Process  
### Program
> 어떤 작업을 위해 실행할 수 있는 파일 
### Process
> 프로그램의 인스턴스 (실행된 프로그램 / 운영체제로 부터 자원을 할당받는)  
ref) 자원 : CPU시간, 주소공간, 메모리 
- 각 프로세스는 별도의 주소 공간에서 실행되며 영향을 주지 않는다
- 프로세스간 통신을 하려면 IPC (파이프, 소켓 등)를 사용해야 한다.
- 최소 1개의 스레드는 있어야 한다.

### Thread
![thread](https://user-images.githubusercontent.com/26560119/58751383-b5d5c980-84d8-11e9-9739-6c2a9644e72b.png)

- 스택만 따로 할당받고 코드 / 데이터 / 힙 공간은 공유한다.
- 프로세스 내의 여러 흐름 (분산처리)
- 스택과 레지스터는 별도로 

### Java Thread
- 일반 쓰레드와 비슷하지만, 주체가 OS가 아니라 JVM이다.
- 자바 스레드는 실행단위 코드 블럭이다.
- 스레드 코드를 작성하고, JVM에게 요청하면 된다.

## 2. 멀티프로세서 vs 멀티스레드
> 멀티스레드가 더 좋겠지..

### 좋은 이유
1) 자원의 효율성 증대
- 프로세스간 Context Switching 시 CPU, 레지스터 , 캐시메모리까지 초기화되어 오버헤드 큼
- 스레드는 프로세스 내 메모리 공유하기 때문에 간단하고, 자원도 덜 든다.

2) 처리비용 감소 / 응답시간 단축
- IPC 필요 없으니 통신 오버헤드 줄어듬 
- 스레드 Context Switching은 스택만 갈아치우면 되니 훨씬 빠름

## 3. Thread Safe
> 여러 스레드가 한 자원에 접근 시 의도대로 동작하는 것

- 공유자원에 접근하는 임계영역을 동기화 기법으로 제어해야 함 (상호배제)
- 동기화 기법은 Mutex, Semaphore 등이 있다.
- 재 진입성 (동시에 어떤 스레드가 와도 같은 결과 보장) 을 보장해야 한다.
- 뮤텍스, 세마포어는 운영체제 커널의 동기화 방법이다. 
- 커널모드 변경하면 성능이 저하된다.

## 4. 뮤텍스와 세마포어 
https://worthpreading.tistory.com/90
### 뮤텍스
- 임계 영역을 가진 스레드들의 러닝타임이 겹치지 않도록 처리 (동시사용 불가)
- 프로세스나 스레드가 뮤텍스 객체를 한번에 하나만 소유가능

### 세마포어
- 세마포어는 OS내부 커널의 한 저장장치 값 (바이너리 일 수도 있고, 아닐수도 있음)
- 이 값을 통해 자원이 사용중인지 알 수 있다.
- 자원을 사용하고 있다면 기다리고, 없다면 드루간다.
- 세마포어를 사용하는 프로세스는 세마포어 값을 확인하고, 자원을 사용하는 동안에는 그 값을 변경함으로써 다른 세마포어 사용자들이 기다리도록 해야함
- 현재 공유자원에 접근할 수 있는 쓰레드, 프로세스의 수를 나타내는 값을 두어 상호배제를 달성하는 기법

### 세마포어와 뮤텍스의 차이
- 세마포어는 뮤텍스가 될수 있지만, 뮤텍스는 세마포어가 될 수 없다
- 간단히 보자면 뮤텍스는 boolean(상태), 세마포어는 int(카운터)
- 뮤텍스는 항상 열쇠 1개이고, 세마포어는 여러개 가질 수 있기 때문에 
세마포어의 열쇠가 1개라면 뮤텍스와 같습니다.
- 세마포어는 파일시스템 상 파일형태 (값) 로 존재, 뮤텍스는 프로세스 범위
- 즉, 프로세스가 사라질 때 뮤텍스는 clean up 됩니다.
- 세마포어는 소유할 수 없는 반면, 뮤텍스는 소유할 수 있습니다.

### Critical Section

임계 구역으로 프로세스 또는 스레드들이 공통 변수들에 접근, 및 수정하고 테이블을 갱신하며, 파일의 읽기, 쓰기 작업들을 수행하는 영역을 말한다. 즉 race condition이 발생하는 영역을 뜻한다. 이미 한 스레드가 Critical Section에 들어갔을 때 다른 스레드들은 이 곳으로의 접근을 막아야한다.



한 프로세스 혹은 한 스레드가 메모리의 어떤 부분을 접근하고 있을 때 다른 프로세스 혹은 스레드가 그 부분을 접근하여 값을 변경하면 안된다. 따라서 그 부분을 막기 위해 우리는 동기화를 해야한다는 개념이 나오는 것이다.

## 5. 가상 메모리
> 가상 메모리란 어떤 프로세스를 실행할때, 프로세스 전체가 메모리에 다 적재되지 않고도 실행이 가능하도록 하는 기법이다.  부분부분 올려서 쓰는것.  
램이 캐시 지원해 주는 느낌 

## 6. 데드락 
- 첫 번째 스레드는 두 번째 스레드가 들고 있는 객체의 락이 풀리기를 기다리고 있고, 두 번째 스레드 역시 첫 번째 스레드가 들고 있는 객체의 락이 풀리기를 기다리는 상황을 일컷는다.
- 모든 스레드가 락이 풀리기를 기다리고 있기 때문에, 무한 대기 상태에 빠지게 된다. 이런 스레드를 교착상태에 빠졌다고 한다.

### 교착상태의 4가지 조건
1. 상호 배제(mutual exclusion)  
한 번에 한 프로세스만 공유 자원을 사용할 수 있다.  
좀 더 정확하게는, 공유 자원에 대한 접근 권한이 제한된다. 자원의 양이 제한되어 있더라도 교착상태는 발생할 수 있다.

2. 들고 기다리기(hold and wait) = 점유대기  
프로세스가 할당된 자원을 가진 상태에서 다른 자원을 기다린다.

3. 선취(preemption) 불가능 = 비선점  
프로세스가 어떤 자원의 사용을 끝낼 때까지 그 자원을 뺏을 수 없다.

4. 대기 상태의 사이클(circular wait) = 순환대기  
두 개 이상의 프로세스가 자원 접근을 기다리는데, 그 관계에 사이클이 존재한다.

### 교착상태 방지
> 4가지 조건들 가운데 하나를 제거하면 된다.

- 공유 자원 중 많은 경우가 한 번에 한 프로세스만 사용할 수 있기 때문에(예를 들어, 프린트) 1번 조건은 제거하기 어렵다.

- 대부분의 교착상태 방지 알고리즘은 4번 조건, 즉 대기 상태의 사이클이 발생하는 일을 막는 데 초점이 맞춰져 있다.

## 7. LRU 캐시
> Least Recently Used 

- CPU가 참조하고자 하는 메모리가 캐시에 존재하고 있을 경우 Cache Hit라고 한다

이떄 Cache를 효율적으로 사용하기 위하며,  
**쓴지 오래된놈은** 뒤로 보내서 꽉 차면 삭제되게 만들고  
**방금 쓰인애는** 앞으로 보내서 캐시에서 삭제되는 것을 방지한다.

